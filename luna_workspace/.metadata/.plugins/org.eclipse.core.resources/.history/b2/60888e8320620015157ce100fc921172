import helper_classes.*;

/* a sandbox for code experimentation.
 * 
 */

public class Scratch {

	///static String latsFileName = "C:\\Users\\glgr9602\\Desktop\\condense\\data\\surface\\SHLATLSB";
	///static String lonsFileName = "C:\\Users\\glgr9602\\Desktop\\condense\\data\\surface\\SHLONLSB";
	///static String coastlineFileName = "C:\\Users\\glgr9602\\Desktop\\condense\\data\\surface\\Sh_loci_land50_landcoast12.5km.1441x1441.bin";

	static String latsFileName = "C:\\Users\\glgr9602\\Desktop\\condense\\data\\surface\\SHLATLSB";
	static String lonsFileName = "C:\\Users\\glgr9602\\Desktop\\condense\\data\\surface\\SHLONLSB";
	static String coastlineFileName = "C:\\Users\\glgr9602\\Desktop\\condense\\data\\surface\\Sh_loci_land50_landcoast12.5km.1441x1441.bin";

	///final static int ROWS = 1441;
	///final static int COLS = 1441;
	
	final static int ROWS = 721;
	final static int COLS = 721;
	
	public static void main(String[] args) {

		SurfaceVector[][] surface = new SurfaceVector[ROWS][COLS];

		// Read the file
		try {

			DataFile latitudes = new DataFile( latsFileName );
			DataFile longitudes = new DataFile( lonsFileName );
			DataFile surfaceFile = new DataFile( coastlineFileName );

			for (int r = 0; r < ROWS; r++) {
				for (int c = 0; c < COLS; c++) {
					
					// Read the encoded data from the files
					int lat = latitudes.readInt();
					int lon = longitudes.readInt();
					byte type = surfaceFile.readByte();
					
					// Reverse the byte order (for Windows).
					lat = Tools.reverseByteOrder(lat);
					lon = Tools.reverseByteOrder(lon);

					// Decode the data, convert to doubles.
					double latD = ((double) lat) / 100000.0;
					double lonD = ((double) lon) / 100000.0;
					
					// Create the suface object at this location
					surface[r][c] = new SurfaceVector( (int) type,
							new GriddedLocation(r,c,latD,lonD), 0);
				}
			}

			latitudes.close();			
			longitudes.close();			
			surfaceFile.close();
		}
		catch(Exception e) {
			Tools.warningMessage("Failed to open file");
		}
		for (int i = 0; i < ROWS; i = i + 10) {
			Tools.message("surface["+i+"]["+i+"] = " + surface[i][i].classification());
		}
	}

	
	/*
	 * makeFile
	 */
	protected void makeFile() {
		/*
		
		// Use the dates to make file names
		Timestamp firstDate = t.startTimestamp();
		Timestamp lastDate = t.endTimestamp();
		Tools.statusMessage("  Climatology: " + firstDate.dateString() + " to " +
				lastDate.dateString() + " in increments of " + increment.toString() +
				" (total days = " + totalDays + ")");

		String filename = "no name";
		Timestamp.dateSeparator("");

		String incName = increment.toString().toLowerCase();
		
		// Write the baseline data to output files
		try {
			// Mean baseline climatology file
			filename = outputPath + climatologyPrefix + dataType.toString() + 
					frequency + polarization +
					"-mean-" + incName + "-" + firstDate.dateString() + ".bin";

			Tools.statusMessage("    mean output filename = " + filename);
			
			DataFile file = new DataFile();
			file.create(filename);
			file.writeDouble2d(mean);
			file.close();
			
			// Standard deviation climatology file
			filename = outputPath + climatologyPrefix + dataType.toString() +
					frequency + polarization +
					"-sd-" + incName + "-" + firstDate.dateString() + ".bin";

			Tools.statusMessage("    sd output filename = " + filename);
			
			file = new DataFile();
			file.create( filename );
			file.writeDouble2d(sd);
			file.close();
		}
		catch(Exception e) {
			Tools.warningMessage("Could not open output baseline data file: " +
					filename);
		}

		Timestamp.dateSeparator(".");
		
		// Warm-fuzzy check...
		int r = 50;
		int c = 50;
		Tools.message("Rows,cols = " + rows + "," + cols); 
		Tools.message("Population at " + r + "," + c + " = " + population[r][c]); 
		Tools.message("Mean at " + r + "," + c + " = " + mean[r][c]); 
		Tools.message("Standard deviation at " + r + "," + c + " = " + sd[r][c]);
		*/ 
	}
}
