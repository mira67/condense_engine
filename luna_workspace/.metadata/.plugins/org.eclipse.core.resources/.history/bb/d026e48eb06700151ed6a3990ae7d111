package helper_classes;

/* Algorithms
 * 
 * Static condensation algorithms
 * 
 */

public class Algorithms extends GeoObject {

	/*
	 * algorithm1
	 * 
	 * Use the climatological mean and standard deviation to condense data.
	 * 
	 */

	public static GriddedVector[][] algorithm1(
			GriddedVector[][] data,
			double[][] mean,
			double[][] sd,
			double sdThreshold) {
		
		int rows = data.length;
		int cols = data[0].length;
		
		GriddedVector[][] condensedData = new GriddedVector[ rows ][ cols ];

		double low;
		double high;

		// PART 1:
		// Keep only the pixels that exceed the threshold value.
		for (int r = 0; r < rows; r++) {
			for (int c = 0; c < cols; c++) {
				
				// Calculate a low and high threshold using the mean and standard deviation
				low = mean[r][c] - sdThreshold * sd[r][c];
				high = mean[r][c] + sdThreshold * sd[r][c];
				
				// If the vector exceeds either threshold, keep it. Otherwise discard it.
				// TODO: should we enable differing high and low thresholds?
				if (data[r][c].data() < low || data[r][c].data() > high) {
					condensedData[r][c] = data[r][c];
				}
			}
		}

		// PART 2:
		// If a pixel doesn't have enough adjacent anomalous pixels, it might be
		// noise -- ignore it.

		// Number of adjacent anomalous pixels necessary for determining
		// that any one pixel is a keeper?
		int minAnomalies = 2;

		for (int r = 0; r < rows; r++) {
			for (int c = 0; c < cols; c++) {
				
				int adjacentAnomalies = 0;
				
				// Look at adjacent pixels, counting the anomalies
				for (int r1 = r-1; r1 < r+2; r1++) {
					for (int c1 = c-1; c1 < c+2; c1++) {
						
						// Don't compare the pixel with itself
						if (r1 == r && c1 == c) continue;
					
						// Don't exceed the array bounds.
						if (r1 < 0 || c1 < 0 || r1 > rows-1 || c1 > cols-1) continue;
						
						// Found one. Count it.
						if (condensedData[r1][c1] != null) adjacentAnomalies++;
					}
				}
				// Did we find enough adjacent anomalous pixels?
				if (adjacentAnomalies < minAnomalies) {
					// Nope.
					condensedData[r][c] = null;
				}
			}
		}
		
		return condensedData;
	}
}
